'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
sapply(1:nrow(data), function(idx) {
browser()
consistency_pre <- sum(data$imm_chosen[0:(idx-1)], na.rm = T)
!data$imm_chosen[(idx):(nrow(data)+1)]
})
}
kirby_score(td_bc_single_ptpt)
data$k
data
kirby_score(td_bc_single_ptpt, k = 'exponential')
data
data
consistency_pre
!data$imm_chosen[(idx):(nrow(data)+1)]
sum(!data$imm_chosen[(idx):(nrow(data)+1)], na.rm = T)
mean(1,2)
kirby_score(td_bc_single_ptpt, k = 'exponential')
kirby_score <- function(data, k = c('hyperbolic', 'exponential')) {
browser()
k <- match.arg(k)
require_columns(data, c('val_imm', 'val_del', 'del', 'imm_chosen'))
data$k <- switch (k,
'hyperbolic' = (data$val_del/data$val_imm - 1) / data$del,
'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
browser()
data$consistency <- sapply(1:nrow(data), function(idx) {
sum(data$imm_chosen[0:(idx-1)], na.rm = T) + sum(!data$imm_chosen[(idx):(nrow(data)+1)], na.rm = T)
})
}
kirby_score(td_bc_single_ptpt, k = 'exponential')
kirby_score(td_bc_single_ptpt, k = 'exponential')
sapply(1:nrow(data), function(idx) {
sum(data$imm_chosen[0:(idx-1)], na.rm = T) + sum(!data$imm_chosen[(idx):(nrow(data)+1)], na.rm = T)
})
data$consistency <- sapply(1:nrow(data), function(idx) {
sum(data$imm_chosen[0:(idx-1)], na.rm = T) + sum(!data$imm_chosen[(idx):(nrow(data)+1)], na.rm = T)
})
data$consistency
plot(data$consistency)
duplicated(data$consistency)
data$consistency[duplicated(data$consistency)]
sort(data$consistency[duplicated(data$consistency)])
max(data$consistency)
which.max(data$consistency)
most_consistent <- which(data$consistency == max(data$consistency))
most_consistent
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
sum(data$imm_chosen[0:(idx-1)], na.rm = T) + sum(!data$imm_chosen[(idx):(nrow(data)+1)], na.rm = T)
})
plot(data$consistency)
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
})
plot(data$consistency)
data
sapply(most_consistent, function(cand) {
exp(mean(log(data$k[(cand-1) : cand])))
})
# Geometric mean
geomean <- function(x, ...) {
exp(mean(log(x), ...))
}
cands <- sapply(most_consistent, function(cand) {
geomean(data$k[(cand-1) : cand])
})
cands
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cand
}
kirby_score <- function(data, k = c('hyperbolic', 'exponential')) {
browser()
k <- match.arg(k)
require_columns(data, c('val_imm', 'val_del', 'del', 'imm_chosen'))
data$k <- switch (k,
'hyperbolic' = (data$val_del/data$val_imm - 1) / data$del,
'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
browser()
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
})
max_consistency <- max(data$consistency)
if (max_consistency < 0.75) {
warning('Maximum consistency score is below 0.75. Inattentive responding?')
}
most_consistent <- which(data$consistency == max_consistency)
cands <- sapply(most_consistent, function(cand) {
geomean(data$k[(cand-1) : cand])
})
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cand
}
}
kirby_score(td_bc_single_ptpt, k = 'exponential')
# Geometric mean
geomean <- function(x, ...) {
exp(mean(log(x), ...))
}
kirby_score(td_bc_single_ptpt, k = 'exponential')
kirby_score(td_bc_single_ptpt, k = 'exponential')
# Geometric mean
geomean <- function(x, ...) {
exp(mean(log(x), ...))
}
kirby_score(td_bc_single_ptpt, k = 'exponential')
# Geometric mean
geomean <- function(x, ...) {
exp(mean(log(x), ...))
}
cands
best_k
kirby_score <- function(data, k = c('hyperbolic', 'exponential')) {
k <- match.arg(k)
require_columns(data, c('val_imm', 'val_del', 'del', 'imm_chosen'))
data$k <- switch (k,
'hyperbolic' = (data$val_del/data$val_imm - 1) / data$del,
'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
})
max_consistency <- max(data$consistency)
if (max_consistency < 0.75) {
warning('Maximum consistency score is below 0.75. Inattentive responding?')
}
most_consistent <- which(data$consistency == max_consistency)
cands <- sapply(most_consistent, function(cand) {
geomean(data$k[(cand-1) : cand])
})
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cand
}
# Construct a dummy td_ipm
mod <- td_ipm(data.frame(indiff = 0.5, del = 1), discount_function = k)
browser()
}
best_k
kirby_score(td_bc_single_ptpt, k = 'exponential')
best_k
mod
mod$config
mod$optim
mod$optim$par <- c(k = best_k)
kirby_score <- function(data, k = c('hyperbolic', 'exponential')) {
k <- match.arg(k)
require_columns(data, c('val_imm', 'val_del', 'del', 'imm_chosen'))
data$k <- switch (k,
'hyperbolic' = (data$val_del/data$val_imm - 1) / data$del,
'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
})
max_consistency <- max(data$consistency)
if (max_consistency < 0.75) {
warning('Maximum consistency score is below 0.75. Inattentive responding?')
}
most_consistent <- which(data$consistency == max_consistency)
cands <- sapply(most_consistent, function(cand) {
geomean(data$k[(cand-1) : cand])
})
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cand
}
# Construct a dummy td_ipm
mod <- td_ipm(data.frame(indiff = 0.5, del = 1), discount_function = k)
mod$optim$par <- c(k = best_k)
return(mod)
}
kirby_score(td_bc_single_ptpt, k = 'exponential')
mod <- kirby_score(td_bc_single_ptpt, k = 'exponential')
plot(mod)
kirby_score <- function(data, k = c('hyperbolic', 'exponential')) {
k <- match.arg(k)
require_columns(data, c('val_imm', 'val_del', 'del', 'imm_chosen'))
data$k <- switch (k,
'hyperbolic' = (data$val_del/data$val_imm - 1) / data$del,
'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
})
max_consistency <- max(data$consistency)
if (max_consistency < 0.75) {
warning('Maximum consistency score is below 0.75. Inattentive responding?')
}
most_consistent <- which(data$consistency == max_consistency)
cands <- sapply(most_consistent, function(cand) {
geomean(data$k[(cand-1) : cand])
})
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cand
}
# Construct a dummy td_ipm
mod <- td_ipm(data.frame(indiff = 0.5, del = 1), discount_function = k)
mod$data <- data
mod$optim <- list(par = c(k = best_k))
return(mod)
}
mod <- kirby_score(td_bc_single_ptpt, k = 'exponential')
plot(mod)
plot(mod, log = 'x')
mod <- td_ipm(td_bc_single_ptpt, discount_function = 'exponential')
mod <- td_bcm(td_bc_single_ptpt, discount_function = 'exponential')
plot(mod)
plot(mod, log = 'x')
devtools::load_all()
devtools::load_all()
#' Indifference point model
#'
#' Compute a model of a single subject's indifference points
#' @export
kirby_score <- function(data, discount_function = c('hyperbolic', 'exponential')) {
discount_function <- match.arg(discount_function)
require_columns(data, c('val_imm', 'val_del', 'del', 'imm_chosen'))
data$k <- switch (discount_function,
'hyperbolic' = (data$val_del/data$val_imm - 1) / data$del,
'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
})
max_consistency <- max(data$consistency)
if (max_consistency < 0.75) {
warning('Maximum consistency score is below 0.75. Inattentive responding?')
}
most_consistent <- which(data$consistency == max_consistency)
cands <- sapply(most_consistent, function(cand) {
geomean(data$k[(cand-1) : cand])
})
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cand
}
# Construct a dummy td_ipm
mod <- td_ipm(data.frame(indiff = 0.5, del = 1), discount_function = discount_function)
mod$data <- data
mod$optim <- list(par = c(k = best_k)) # Remove other meaningless optim() info
browser()
return(mod)
}
mod <- kirby_score(td_bc_single_ptpt, k = 'exponential')
mod <- kirby_score(td_bc_single_ptpt, discount_function = 'exponential')
mod
data("td_bc_single_ptpt")
mod <- kirby_score(td_bc_single_ptpt)
#' @param data Responses to score.
#' @param discount_function Should \eqn{k} values be computed according to the hyperbolic or exponential discount function? The original method uses the hyperbolic, but in principle the exponential is also possible.
#' @return An object of class \code{td_ipm}.
#' @examples
#' \dontrun{
#' data("td_bc_single_ptpt")
#' mod <- kirby_score(td_bc_single_ptpt)
#'
#' }
#' @export
kirby_score <- function(data, discount_function = c('hyperbolic', 'exponential')) {
discount_function <- match.arg(discount_function)
require_columns(data, c('val_imm', 'val_del', 'del', 'imm_chosen'))
data$k <- switch (discount_function,
'hyperbolic' = (data$val_del/data$val_imm - 1) / data$del,
'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
})
max_consistency <- max(data$consistency)
if (max_consistency < 0.75) {
warning('Maximum consistency score is below 0.75. Inattentive responding?')
}
most_consistent <- which(data$consistency == max_consistency)
cands <- sapply(most_consistent, function(cand) {
geomean(data$k[(cand-1) : cand])
})
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cand
}
# Construct dummy td_ipm
mod <- list(
data = data,
discount_function = td_fn(predefined = discount_function),
optim = list(par = c(k = best_k))
)
class(mod) <- c('td_ipm', 'td_um')
return(mod)
}
mod <- kirby_score(td_bc_single_ptpt)
#' @param data Responses to score.
#' @param discount_function Should \eqn{k} values be computed according to the hyperbolic or exponential discount function? The original method uses the hyperbolic, but in principle the exponential is also possible.
#' @return An object of class \code{td_ipm}.
#' @examples
#' \dontrun{
#' data("td_bc_single_ptpt")
#' mod <- kirby_score(td_bc_single_ptpt)
#'
#' }
#' @export
kirby_score <- function(data, discount_function = c('hyperbolic', 'exponential')) {
discount_function <- match.arg(discount_function)
require_columns(data, c('val_imm', 'val_del', 'del', 'imm_chosen'))
data$k <- switch (discount_function,
'hyperbolic' = (data$val_del/data$val_imm - 1) / data$del,
'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
})
max_consistency <- max(data$consistency)
if (max_consistency < 0.75) {
warning('Maximum consistency score is below 0.75. Inattentive responding?')
}
most_consistent <- which(data$consistency == max_consistency)
cands <- sapply(most_consistent, function(cand) {
browser()
geomean(data$k[(cand-1) : cand])
})
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cand
}
# Construct dummy td_ipm
mod <- list(
data = data,
discount_function = td_fn(predefined = discount_function),
optim = list(par = c(k = best_k))
)
class(mod) <- c('td_ipm', 'td_um')
return(mod)
}
mod <- kirby_score(td_bc_single_ptpt)
cand
#' @param data Responses to score.
#' @param discount_function Should \eqn{k} values be computed according to the hyperbolic or exponential discount function? The original method uses the hyperbolic, but in principle the exponential is also possible.
#' @return An object of class \code{td_ipm}.
#' @examples
#' \dontrun{
#' data("td_bc_single_ptpt")
#' mod <- kirby_score(td_bc_single_ptpt)
#'
#' }
#' @export
kirby_score <- function(data, discount_function = c('hyperbolic', 'exponential')) {
discount_function <- match.arg(discount_function)
require_columns(data, c('val_imm', 'val_del', 'del', 'imm_chosen'))
data$k <- switch (discount_function,
'hyperbolic' = (data$val_del/data$val_imm - 1) / data$del,
'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
})
max_consistency <- max(data$consistency)
if (max_consistency < 0.75) {
warning('Maximum consistency score is below 0.75. Inattentive responding?')
}
most_consistent <- which(data$consistency == max_consistency)
cands <- sapply(most_consistent, function(cand) {
browser()
geomean(data$k[(cand-1) : cand])
})
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cand
}
# Construct dummy td_ipm
mod <- list(
data = data,
discount_function = td_fn(predefined = discount_function),
optim = list(par = c(k = best_k))
)
class(mod) <- c('td_ipm', 'td_um')
return(mod)
}
mod <- kirby_score(td_bc_single_ptpt)
geomean(data$k[(cand-1) : cand])
mod <- kirby_score(td_bc_single_ptpt)
#' @param data Responses to score.
#' @param discount_function Should \eqn{k} values be computed according to the hyperbolic or exponential discount function? The original method uses the hyperbolic, but in principle the exponential is also possible.
#' @return An object of class \code{td_ipm}.
#' @examples
#' \dontrun{
#' data("td_bc_single_ptpt")
#' mod <- kirby_score(td_bc_single_ptpt)
#'
#' }
#' @export
kirby_score <- function(data, discount_function = c('hyperbolic', 'exponential')) {
discount_function <- match.arg(discount_function)
require_columns(data, c('val_imm', 'val_del', 'del', 'imm_chosen'))
data$k <- switch (discount_function,
'hyperbolic' = (data$val_del/data$val_imm - 1) / data$del,
'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
})
max_consistency <- max(data$consistency)
if (max_consistency < 0.75) {
warning('Maximum consistency score is below 0.75. Inattentive responding?')
}
most_consistent <- which(data$consistency == max_consistency)
cands <- sapply(most_consistent, function(cand) {
geomean(data$k[(cand-1) : cand])
})
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cands
}
# Construct dummy td_ipm
mod <- list(
data = data,
discount_function = td_fn(predefined = discount_function),
optim = list(par = c(k = best_k))
)
class(mod) <- c('td_ipm', 'td_um')
return(mod)
}
mod <- kirby_score(td_bc_single_ptpt)
mod
td_ipm(td_bc_single_ptpt, discount_function = 'exponential')
data("td_ip_simulated_ptpt")
td_ipm(td_ip_simulated_ptpt, discount_function = 'exponential')
mod <- td_ipm(td_ip_simulated_ptpt, discount_function = 'exponential')
mod$config
library(testthat)
data("td_bc_single_ptpt")
# Random responding
set.seed(123)
td_bc_single_ptpt$imm_chosen <- round(runif(nrow(td_bc_single_ptpt)))
kirby_score(td_bc_single_ptpt)
devtools::load_all()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::load_all()
# Random responding
set.seed(123)
td_bc_single_ptpt$imm_chosen <- round(runif(nrow(td_bc_single_ptpt)))
kirby_score(td_bc_single_ptpt)
expect_warning(kirby_score(td_bc_single_ptpt))
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
mod <- kirby_score(td_bc_single_ptpt)
residuals(mod)
devtools::load_all()
residuals(mod)
yhat
y
mod <- td_bcm(td_bc_single_ptpt)
mod <- td_bcm(td_bc_single_ptpt, discount_function = 'hyperbolic')
mod
mod$config
mod <- kirby_score(td_bc_single_ptpt)
plot(mod)
