geomean(data$k[(cand-1) : cand])
})
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cand
}
# Construct a dummy td_ipm
mod <- td_ipm(data.frame(indiff = 0.5, del = 1), discount_function = discount_function)
mod$data <- data
mod$optim <- list(par = c(k = best_k)) # Remove other meaningless optim() info
browser()
return(mod)
}
mod <- kirby_score(td_bc_single_ptpt, k = 'exponential')
mod <- kirby_score(td_bc_single_ptpt, discount_function = 'exponential')
mod
data("td_bc_single_ptpt")
mod <- kirby_score(td_bc_single_ptpt)
#' @param data Responses to score.
#' @param discount_function Should \eqn{k} values be computed according to the hyperbolic or exponential discount function? The original method uses the hyperbolic, but in principle the exponential is also possible.
#' @return An object of class \code{td_ipm}.
#' @examples
#' \dontrun{
#' data("td_bc_single_ptpt")
#' mod <- kirby_score(td_bc_single_ptpt)
#'
#' }
#' @export
kirby_score <- function(data, discount_function = c('hyperbolic', 'exponential')) {
discount_function <- match.arg(discount_function)
require_columns(data, c('val_imm', 'val_del', 'del', 'imm_chosen'))
data$k <- switch (discount_function,
'hyperbolic' = (data$val_del/data$val_imm - 1) / data$del,
'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
})
max_consistency <- max(data$consistency)
if (max_consistency < 0.75) {
warning('Maximum consistency score is below 0.75. Inattentive responding?')
}
most_consistent <- which(data$consistency == max_consistency)
cands <- sapply(most_consistent, function(cand) {
geomean(data$k[(cand-1) : cand])
})
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cand
}
# Construct dummy td_ipm
mod <- list(
data = data,
discount_function = td_fn(predefined = discount_function),
optim = list(par = c(k = best_k))
)
class(mod) <- c('td_ipm', 'td_um')
return(mod)
}
mod <- kirby_score(td_bc_single_ptpt)
#' @param data Responses to score.
#' @param discount_function Should \eqn{k} values be computed according to the hyperbolic or exponential discount function? The original method uses the hyperbolic, but in principle the exponential is also possible.
#' @return An object of class \code{td_ipm}.
#' @examples
#' \dontrun{
#' data("td_bc_single_ptpt")
#' mod <- kirby_score(td_bc_single_ptpt)
#'
#' }
#' @export
kirby_score <- function(data, discount_function = c('hyperbolic', 'exponential')) {
discount_function <- match.arg(discount_function)
require_columns(data, c('val_imm', 'val_del', 'del', 'imm_chosen'))
data$k <- switch (discount_function,
'hyperbolic' = (data$val_del/data$val_imm - 1) / data$del,
'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
})
max_consistency <- max(data$consistency)
if (max_consistency < 0.75) {
warning('Maximum consistency score is below 0.75. Inattentive responding?')
}
most_consistent <- which(data$consistency == max_consistency)
cands <- sapply(most_consistent, function(cand) {
browser()
geomean(data$k[(cand-1) : cand])
})
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cand
}
# Construct dummy td_ipm
mod <- list(
data = data,
discount_function = td_fn(predefined = discount_function),
optim = list(par = c(k = best_k))
)
class(mod) <- c('td_ipm', 'td_um')
return(mod)
}
mod <- kirby_score(td_bc_single_ptpt)
cand
#' @param data Responses to score.
#' @param discount_function Should \eqn{k} values be computed according to the hyperbolic or exponential discount function? The original method uses the hyperbolic, but in principle the exponential is also possible.
#' @return An object of class \code{td_ipm}.
#' @examples
#' \dontrun{
#' data("td_bc_single_ptpt")
#' mod <- kirby_score(td_bc_single_ptpt)
#'
#' }
#' @export
kirby_score <- function(data, discount_function = c('hyperbolic', 'exponential')) {
discount_function <- match.arg(discount_function)
require_columns(data, c('val_imm', 'val_del', 'del', 'imm_chosen'))
data$k <- switch (discount_function,
'hyperbolic' = (data$val_del/data$val_imm - 1) / data$del,
'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
})
max_consistency <- max(data$consistency)
if (max_consistency < 0.75) {
warning('Maximum consistency score is below 0.75. Inattentive responding?')
}
most_consistent <- which(data$consistency == max_consistency)
cands <- sapply(most_consistent, function(cand) {
browser()
geomean(data$k[(cand-1) : cand])
})
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cand
}
# Construct dummy td_ipm
mod <- list(
data = data,
discount_function = td_fn(predefined = discount_function),
optim = list(par = c(k = best_k))
)
class(mod) <- c('td_ipm', 'td_um')
return(mod)
}
mod <- kirby_score(td_bc_single_ptpt)
geomean(data$k[(cand-1) : cand])
mod <- kirby_score(td_bc_single_ptpt)
#' @param data Responses to score.
#' @param discount_function Should \eqn{k} values be computed according to the hyperbolic or exponential discount function? The original method uses the hyperbolic, but in principle the exponential is also possible.
#' @return An object of class \code{td_ipm}.
#' @examples
#' \dontrun{
#' data("td_bc_single_ptpt")
#' mod <- kirby_score(td_bc_single_ptpt)
#'
#' }
#' @export
kirby_score <- function(data, discount_function = c('hyperbolic', 'exponential')) {
discount_function <- match.arg(discount_function)
require_columns(data, c('val_imm', 'val_del', 'del', 'imm_chosen'))
data$k <- switch (discount_function,
'hyperbolic' = (data$val_del/data$val_imm - 1) / data$del,
'exponential' = -log(data$val_imm/data$val_del) / data$del
)
data <- data[order(data$k), ]
data$consistency <- sapply(1:nrow(data), function(idx) {
mean(c(data$imm_chosen[0:(idx-1)],
!data$imm_chosen[(idx):(nrow(data)+1)]),
na.rm = T)
})
max_consistency <- max(data$consistency)
if (max_consistency < 0.75) {
warning('Maximum consistency score is below 0.75. Inattentive responding?')
}
most_consistent <- which(data$consistency == max_consistency)
cands <- sapply(most_consistent, function(cand) {
geomean(data$k[(cand-1) : cand])
})
if (length(cands) > 1) {
best_k <- geomean(cands)
} else {
best_k <- cands
}
# Construct dummy td_ipm
mod <- list(
data = data,
discount_function = td_fn(predefined = discount_function),
optim = list(par = c(k = best_k))
)
class(mod) <- c('td_ipm', 'td_um')
return(mod)
}
mod <- kirby_score(td_bc_single_ptpt)
mod
td_ipm(td_bc_single_ptpt, discount_function = 'exponential')
data("td_ip_simulated_ptpt")
td_ipm(td_ip_simulated_ptpt, discount_function = 'exponential')
mod <- td_ipm(td_ip_simulated_ptpt, discount_function = 'exponential')
mod$config
library(testthat)
data("td_bc_single_ptpt")
# Random responding
set.seed(123)
td_bc_single_ptpt$imm_chosen <- round(runif(nrow(td_bc_single_ptpt)))
kirby_score(td_bc_single_ptpt)
devtools::load_all()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::load_all()
# Random responding
set.seed(123)
td_bc_single_ptpt$imm_chosen <- round(runif(nrow(td_bc_single_ptpt)))
kirby_score(td_bc_single_ptpt)
expect_warning(kirby_score(td_bc_single_ptpt))
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
mod <- kirby_score(td_bc_single_ptpt)
residuals(mod)
devtools::load_all()
residuals(mod)
yhat
y
mod <- td_bcm(td_bc_single_ptpt)
mod <- td_bcm(td_bc_single_ptpt, discount_function = 'hyperbolic')
mod
mod$config
mod <- kirby_score(td_bc_single_ptpt)
plot(mod)
devtools::load_all()
data("td_bc_single_ptpt")
td_bcm(td_bc_single_ptpt, discount_function = 'hyperbolic')
mod <- td_bcm(td_bc_single_ptpt, discount_function = 'hyperbolic')
mod
mod$config
class(mod)
devtools::load_all()
kirby_score(td_bc_single_ptpt)
mod <- kirby_score(td_bc_single_ptpt)
plot(mod)
plot(mod, log = 'x')
devtools::load_all()
mod <- kirby_score(td_bc_single_ptpt)
mod
plot(mod, log = 'x')
devtools::load_all()
mod <- kirby_score(td_bc_single_ptpt)
BIC(mod)
logLik(mod)
AIC(mod)
mod
View(logLik.td_bcm)
devtools::load_all()
logLik(mod)
p
logLik(mod)
prob_mod
coef(object)
probs
is.finite(Inf)
devtools::load_all()
mod <- kirby_score(td_bc_single_ptpt)
plot(mod)
plot(mod, type = 'endpoints')
plot(mod, type = 'link')
logLik(mod)
p
val
mod
devtools::test()
devtools::test()
devtools::test()
devtools::test('ipm')
devtools::test(filter = 'ipm')
...
list(...)
length(...)
devtools::test(filter = 'ipm')
devtools::test(filter = 'ipm')
devtools::test(filter = 'ipm')
View(logLik.td_ipm)
mod
kirby_score(adj_amt_sim)
mod <- kirby_score(adj_amt_sim)
plot(mod)
class(NA)
type(NA)
typeof(NA)
mod
devtools::test(filter = 'ipm')
devtools::test()
plot(mod)
plot(mod, type = 'endpoints')
devtools::load_all()
x <- subset(td_bc_study, id == unique(td_bc_study$id)[4])
data("td_bc_study")
x <- subset(td_bc_study, id == unique(td_bc_study$id)[4])
mod <- td_bclm(x, model = 'itch')
plot(mod, log = 'x')
devtools::load_all()
data("td_bc_study")
x <- subset(td_bc_study, id == unique(td_bc_study$id)[1])
mod <- td_bclm(x, model = 'itch')
plot(mod, log = 'x')
x <- subset(td_bc_study, id == unique(td_bc_study$id)[4])
mod <- td_bclm(x, model = 'naive')
plot(mod, log = 'x')
plot(mod, type = 'link')
plot(mod, type = 'endpoints')
devtools::load_all()
data("td_bc_study")
x <- subset(td_bc_study, id == unique(td_bc_study$id)[5])
mod <- td_bclm(x, model = 'naive')
plot(mod, log = 'x')
mod <- td_bclm(x, model = 'itch')
plot(mod, log = 'x')
x <- subset(td_bc_study, id == unique(td_bc_study$id)[6])
mod <- td_bclm(x, model = 'itch')
plot(mod, log = 'x')
x <- subset(td_bc_study, id == unique(td_bc_study$id)[7])
mod <- td_bclm(x, model = 'itch')
plot(mod, log = 'x')
plot(mod, type = 'endpoints')
plot(mod, type = 'link')
x <- subset(td_bc_study, id == unique(td_bc_study$id)[8])
mod <- td_bclm(x, model = 'itch')
plot(mod, log = 'x')
x <- subset(td_bc_study, id == unique(td_bc_study$id)[9])
mod <- td_bclm(x, model = 'itch')
plot(mod, log = 'x')
mod <- td_bclm(x, model = 'naive')
plot(mod, log = 'x')
kirby_score(x)
mod <- kirby_score(x)
plot(mod)
plot(mod, log = 'x')
mod <- kirby_score(x, discount_function = 'exponential')
plot(mod, log = 'x')
devtools::check()
View(ED50)
View(predict.td_ipm)
devtools::check()
report(file = 'dev/report.html')
library(covr)
report(file = 'dev/report.html')
detach('package:tempodisco', unload = T)
report(file = 'dev/report.html')
devtools::load_all()
?adj_amt_indiffs
?kirby_score
?wileyto_score
devtools::document()
?kirby_score
devtools::document()
?kirby_score
usethis::use_vignette('adjusting-amounts')
library(tempodisco)
vignette("a01-pbkrtest")
data("adj_amt_sim")
head(adj_amt_sim)
data("adj_amt_sim")
head(adj_amt_sim)
head(adj_amt_sim)
scored <- adj_amt_indiffs(adj_amt_sim)
head(scored)
?adj_amt_indiffs
scored <- adj_amt_indiffs(adj_amt_sim, block_indic = 'del', order_indic = 'trial_idx')
head(scored)
mod <- td_ipm(scored, discount_function = c('hyperbolic'))
plot(mod)
plot(mod, log = 'x')
plot(mod)
usethis::use_vignette('model-free-auc')
library(tempodisco)
data("td_bc_single_ptpt")
mod <- td_bcm(td_bc_single_ptpt, discount_function = 'model-free')
plot(mod)
plot(mod, log = 'x')
plot(mod)
data("td_ip_simulated_ptpt")
data("td_ip_simulated_ptpt")
mod <- td_ipm(td_ip_simulated_ptpt, discount_function = 'model-free')
plot(mod)
print(AUC(mod))
data("td_ip_simulated_ptpt")
mod <- td_ipm(td_ip_simulated_ptpt, discount_function = 'model-free')
plot(mod)
print(AUC(mod))
data("td_ip_simulated_ptpt")
mod <- td_ipm(td_ip_simulated_ptpt, discount_function = 'model-free')
print(AUC(mod))
View(AUC)
devtools::load_all()
View(AUC)
print(AUC(mod))
View(td_fn)
td_ip_simulated_ptpt$del <- log(td_ip_simulated_ptpt$del)
mod <- td_ipm(td_ip_simulated_ptpt, discount_function = 'model-free')
plot(mod)
AUC(mod)
print(AUC(mod))
td_ip_simulated_ptpt$del <- factor(td_ip_simulated_ptpt$del)
mod <- td_ipm(td_ip_simulated_ptpt, discount_function = 'model-free')
td_ip_simulated_ptpt$del <- as.numeric(factor(td_ip_simulated_ptpt$del, ordered = T))
mod <- td_ipm(td_ip_simulated_ptpt, discount_function = 'model-free')
plot(mod)
print(AUC(mod))
print(AUC(mod))
df <- adj_amt_indiffs(adj_amt_sim)
df
df <- adj_amt_indiffs(adj_amt_sim)
df$del <- log(df$del)
mod <- td_ipm(df, discount_function = 'model-free')
plot(mod)
print(AUC(mod))
View(AUC)
print(AUC(mod, min_del = 1, max_del = 100))
data("td_ip_simulated_ptpt")
mod <- td_ipm(td_ip_simulated_ptpt, discount_function = 'model-free')
print(AUC(mod))
data("td_ip_simulated_ptpt")
mod <- td_ipm(td_ip_simulated_ptpt, discount_function = 'model-free')
print(AUC(mod))
```{r}
data("td_ip_simulated_ptpt")
mod <- td_ipm(td_ip_simulated_ptpt, discount_function = 'model-free')
print(AUC(mod))
print(AUC(mod, min_del = 1, max_del = 100))
predict(mod, del = 1:10)
plot(predict(mod, del = 1:10))
plot(predict(mod, del = 1:100))
plot(predict(mod, del = log(1:100)))
data("adj_amt_sim")
indiffs <- adj_amt_indiffs(adj_amt_sim)
mod <- td_ipm(indiffs, discount_function = 'model-free')
print(AUC(mod))
print(AUC(mod, min_del = 1, max_del = 100))
data("adj_amt_sim")
df <- adj_amt_indiffs(adj_amt_sim)
mod <- td_ipm(df, discount_function = 'model-free')
print(AUC(mod))
print(AUC(mod, min_del = 1, max_del = 100))
df$untransformed_del <- df$del # Save a copy
df$del <- log(df$untransformed_del)
mod <- td_ipm(df, discount_function = 'model-free')
plot(mod)
factor(df$untransformed_del)
factor(df$untransformed_del, ordered = T)
as.numeric(factor(df$untransformed_del, ordered = T))
df$untransformed_del <- df$del # Save a copy
df$del <- as.numeric(factor(df$untransformed_del, ordered = T))
mod <- td_ipm(df, discount_function = 'model-free')
plot(mod)
print(AUC(mod))
df$del <- as.numeric(factor(df$untransformed_del, ordered = T))
mod <- td_ipm(df, discount_function = 'model-free')
print(AUC(mod))
df$untransformed_del <- df$del # Save a copy
df$del <- log(df$untransformed_del)
mod <- td_ipm(df, discount_function = 'model-free')
print(AUC(mod))
devtools::install()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(tempodisco)
# Compute indifference points
data("adj_amt_sim")
df <- adj_amt_indiffs(adj_amt_sim)
# Fit model
mod <- td_ipm(df, discount_function = 'model-free')
print(AUC(mod))
print(AUC(mod, min_del = 1, max_del = 100))
df$untransformed_del <- df$del # Save a copy
df$del <- log(df$untransformed_del)
mod <- td_ipm(df, discount_function = 'model-free')
print(AUC(mod))
df$del <- as.numeric(factor(df$untransformed_del, ordered = T))
mod <- td_ipm(df, discount_function = 'model-free')
print(AUC(mod))
View(AUC)
devtools::load_all()
devtools::install()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(tempodisco)
# Compute indifference points
data("adj_amt_sim")
df <- adj_amt_indiffs(adj_amt_sim)
